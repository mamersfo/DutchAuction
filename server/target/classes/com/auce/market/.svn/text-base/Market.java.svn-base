package com.auce.market;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.auce.auction.entity.Lot;
import com.auce.auction.entity.Product;
import com.auce.auction.event.Bid;
import com.auce.auction.event.Event;
import com.auce.auction.event.EventMapper;
import com.auce.auction.event.Offer;
import com.auce.auction.event.Quote;
import com.auce.auction.repository.Repository;
import com.auce.bank.AbstractAccount;
import com.auce.bank.Account;
import com.auce.bank.AccountType;
import com.auce.bank.Bank;
import com.auce.util.component.ComponentSupport;
import com.auce.util.multicast.MulticastChannel;
import com.auce.util.multicast.MulticastChannelEvent;
import com.auce.util.multicast.MulticastChannelListener;

public class Market extends ComponentSupport implements MulticastChannelListener
{
	final static protected Logger logger = LoggerFactory.getLogger( Market.class );
	
	private final Bank				bank;
	private final Account			account;
	protected MulticastChannel		channel;
	protected Map<String,Quoter>	quoters;
	protected Repository			repository;
	protected EventMapper			mapper;
	
	public Market( String id, Bank bank )
	{
		super( id );
		
		this.bank = bank;
		
		String accountNumber = bank.issueAccountNumber();
		bank.openAccount( AccountType.CHECKING, accountNumber, "Market", "Rotterdam" );		
		this.account = bank.findAccount( accountNumber );
		((AbstractAccount)account).setBalance( Long.MAX_VALUE );	
		
		try
		{
			this.period = Integer.parseInt( System.getProperty( "market.period" ) );
			
			this.quoters = new HashMap<String,Quoter>();
	
			// channel
			
			this.channel = new MulticastChannel( this.id );
			
			this.channel.setGroup( 
				InetAddress.getByName( System.getProperty( "market.address" ) ) );
	
			this.channel.setPort( 
				Integer.parseInt( System.getProperty( "market.port" ) ) );
			
			this.channel.setTtl( 
				Integer.parseInt( System.getProperty( "market.ttl" ) ) );
			
			this.channel.addChannelListener( this );
		}
		catch( UnknownHostException e )
		{
			e.printStackTrace();
		}
	}
	
	public Bank getBank()
	{
		return this.bank;
	}
	
	public Account getAccount()
	{
		return this.account;
	}
	
	public void start()
	{
		if ( this.repository == null )
		{
			throw new IllegalStateException( "repository not initialized" );
		}
		
		logger.info( "starting {} with id {}", 
			this.getClass().getSimpleName(), this.id );

		this.channel.start();

		super.start();
	}
	
	public MulticastChannel getChannel ()
	{
		return channel;
	}
	
	public void send( Event event )
	{
		try
		{
			String message = this.mapper.write( event );
			
			this.channel.sendMessage( this.id, message );
		}
		catch( Exception e )
		{
			logger.error( e.getMessage() );
		}
	}
	
	public void handleEvent ( MulticastChannelEvent messageEvent )
	{
		String sender = messageEvent.getSender();
		
		for ( String text : messageEvent.lines() )
		{
			try
			{
				Event event =  this.mapper.read( sender, text );
				
				if ( event != null && event instanceof Offer )
				{
					Offer offer = (Offer)event;
					
					this.addOffer( offer );
					
					Buyer buyer = new Buyer( this, offer );
					
					new Thread( buyer ).start();					
				}
			}
			catch( Exception e )
			{
				logger.error( e.getMessage(), e );
			}
		}
	}
	
	@Override
	protected void beforeRunning ()
	{
		if ( this.repository == null )
		{
			throw new IllegalStateException( "missing dependency: repository" );
		}
		
		Product[] products = this.repository.listProducts();
		
		for ( int i=0; i < products.length; i++ )
		{
			String productId = products[i].getId();
			
			String values = System.getProperty( "market.price." + productId );
			
			logger.info( "product: {}, values: {}", productId, values );
			
			String[] params = values.split( "," );			
			
			Quoter generator = 
				new Quoter( 
					products[i], 						// product 
					Double.parseDouble( params[0] ),    // price
					Double.parseDouble( params[1] ),    // drift
					Double.parseDouble( params[2] )     // volatility
				);

			this.quoters.put( products[i].getId(), generator );
		}		
	}

	@Override
	protected void poll ()
	{
		try
		{
			StringBuilder sb = new StringBuilder();

			for ( Quoter generator : this.quoters.values() )
			{
				Quote quote = generator.getNextQuote2();
				
				sb.append( this.mapper.write( quote ) );
				
				sb.append( "\n" );
			}
			
			String msg = sb.toString();
			
			this.channel.sendMessage( this.id, msg );
		}
		catch ( IOException e )
		{
			logger.error( e.getMessage(), e );
		}
	}

	public Repository getRepository ()
	{
		return repository;
	}

	public void setRepository ( Repository repository )
	{
		this.repository = repository;
		
		this.mapper = new EventMapper( this.repository );
	}

	public Quoter getQuoter ( Product product )
	{
		return this.quoters.get( product.getId() );
	}
	
	public void addOffer( Offer offer )
	{
		// adjust market price, market price goes down on offer

		Product product = offer.getProduct();
		if ( product == null ) return;
		
		Quoter quoter = this.getQuoter( product );
		if ( quoter == null ) return;

		quoter.setMu( quoter.getMu() - offer.getQuantity() * 0.00001 );
	}
	
	public void addBid ( Bid bid )
	{
		// adjust market price, market price goes up on bid
		
		if ( bid == null ) return;
		
		Lot lot = bid.getLot();
		if ( lot == null ) return;
			
		Product product = lot.getProduct();
		if ( product == null ) return;
		
		Quoter quoter = this.getQuoter( product );
		if ( quoter == null ) return;

		quoter.setMu( quoter.getMu() + bid.getQuantity() * 0.00001 );
	}
}
